---
layout: article
title: 再帰処理で求めるnPr
tags: JavaScript
aside:
  toc: true
---

<script type="text/javascript" src="//cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

# この記事について

難易度の高いプログラミングクイズを解くにあたり、避けて通れないのが再帰処理でした。
そのなかでも「順列」は特に使いこなせるようになりたかったので調べて記事にまとめました。

以下の説明をしています。

-   順列とは何か
-   再帰処理とは何か
-   順列を出力するサンプルプログラム

以下は説明しません。
- [公式(nPr)を使った順列パターン数の算出方法]()

# 順列とは何か

## 結論

順列(nPr)は、「n個の物の中からr個を取り出して一列に並べたもの」です。<br>
`nPr`の`P`は`permutation`の略で、そのまま「順列」という意味です。<br>
例えば3匹の動物から2匹を取り出して一列に並べると、以下のような順列になります。

![image](https://user-images.githubusercontent.com/44778704/87756385-ce6f8300-c843-11ea-8315-1d6f5ba5e241.png)

## nCr との違いに注意

注意しなければならないのは、`「1:ねずみ」「2:うし」`と`「1:うし」「2:ねずみ」`は**異なるもの**だという点です。<br>

![image](https://user-images.githubusercontent.com/44778704/87757215-3d011080-c845-11ea-8f8a-fbdd8010266b.png)

上記を「同じ」とみなす考え方は「組み合わせ(`nCr`)」といいます。<br>
この2つはよく混同されますが**別物**なので気をつけてください。<br>

nCrについては以下の記事がわかりやすかったです。

[５分で分かる！確率統計「nCr」の計算方法](https://blog.apar.jp/data-analysis/3927/)
## 順列の洗い出し方

どのように並べれば順列を取得のか、例を上げて解説します。

### <img src ="https://latex.codecogs.com/gif.latex?\inline&space;\LARGE&space;_{4}P_{2}" />の例

4匹の動物[ねずみ][うし][とら][うさぎ]から2匹選んで並べるとき、以下の手順で並べるとパターンを網羅できます。

1. [ねずみ]と[それ以外の動物]をそれぞれ組み合わせる
2. [うし]と[それ以外の動物]をそれぞれ組み合わせる
3. [とら]と[それ以外の動物]をそれぞれ組み合わせる
4. [うさぎ]と[それ以外の動物]をそれぞれ組み合わせる

  ```
  🐭
  - [ねずみ]と
      - [うし]
      - [とら]
      - [うさぎ]

  🐮
  - [うし]と
      - [ねずみ]
      - [とら]
      - [うさぎ]

  🐯
  - [とら]と
      - [ねずみ]
      - [うし]
      - [うさぎ]

  🐰
  - [うさぎ]と
      - [ねずみ]
      - [うし]
      - [とら]
```



4匹の動物それぞれに対して3匹ずつ組み合わせられるので `4 × 3 = 12 通り` の順列ができあがります。


### <img src ="https://latex.codecogs.com/gif.latex?\inline&space;\LARGE&space;_{4}P_{3}" />の例

4匹の動物[ねずみ][うし][とら][うさぎ]から3匹選んで並べるとき、以下の手順で並べるとパターンを網羅できます。

1. [ねずみ]と[うし]と[それ以外の動物]をそれぞれ組み合わせる
2. [ねずみ]と[とら]と[それ以外の動物]をそれぞれ組み合わせる
3. [ねずみ]と[うさぎ]]と[それ以外の動物]をそれぞれ組み合わせる
4. [うし]と[ねずみ]と[それ以外の動物]をそれぞれ組み合わせる
5. [うし]と[とら]と[それ以外の動物]をそれぞれ組み合わせる
6. [うし]と[うさぎ]]と[それ以外の動物]をそれぞれ組み合わせる
7. [とら]と[ねずみ]と[それ以外の動物]をそれぞれ組み合わせる
8. [とら]と[うし]と[それ以外の動物]をそれぞれ組み合わせる
9. [とら]と[うさぎ]]と[それ以外の動物]をそれぞれ組み合わせる
10. [うさぎ]と[ねずみ]と[それ以外の動物]をそれぞれ組み合わせる
11. [うさぎ]と[うし]と[それ以外の動物]をそれぞれ組み合わせる
12. [うさぎ]と[とら]と[それ以外の動物]をそれぞれ組み合わせる


  ```

  🐭
  - [ねずみ]と
      - [うし]と
          - [とら]
          - [うさぎ]
      - [とら]と
          - [うし]
          - [うさぎ]
      - [うさぎ]と
          - [うし]
          - [とら]

  🐮
  - [うし]と
      - [ねずみ]と
          - [とら]
          - [うさぎ]
      - [とら]と
          - [ねずみ]
          - [うさぎ]
      - [うさぎ]と
          - [ねずみ]
          - [とら]

  🐯
  - [とら]と
      - [ねずみ]と
          - [うし]
          - [うさぎ]
      - [うし]と
          - [ねずみ]
          - [うさぎ]
      - [うさぎ]と
          - [ねずみ]
          - [うし]

  🐰
  - [うさぎ]と
      - [ねずみ]と
          - [うし]
          - [とら]
      - [うし]と
          - [ねずみ]
          - [とら]
      - [とら]と
          - [ねずみ]
          - [うし]
```

4匹の動物それぞれに対して3匹ずつ組み合わせられ、さらにそこから2匹ずつ組み合わせが可能です。<br>
よって `4 × 3 × 2 = 24通り` の順列になるはずです。

### 余談: 順列の並べ方の総数

上記で説明したように、順列は並べる数('r')が増えれば増えるほどパターンの総数も倍々に増えていきます。<br>
その総数を知りたい場合は「nのr回分の階乗」を求めればOKです。<br>
`階乗`はその数から1ずつ引いた数を掛け合わせた数のことで、たとえば`5の階乗`は`5*4*3*2*1`です。<br>
<br>
いくつか例をみるとわかりやすいと思います。

- 5種類から3つ選んで並べる(5の3回分の階乗)<br>
<img src= "https://latex.codecogs.com/gif.latex?\LARGE&space;_{5}P_{3}=5\times&space;4&space;\times3&space;" /><br>

- 6種類から4つ選んで並べる(6の4回分の階乗)<br>
<img src= "https://latex.codecogs.com/gif.latex?\LARGE&space;_{6}P_{4}=&space;6&space;\times&space;5&space;\times&space;4&space;\times&space;3" /><br>

- 5種類から1つ選んで並べる(5の1回分の階乗)<br>
<img src= "https://latex.codecogs.com/gif.latex?\LARGE&space;_{5}P_{1}=&space;5" /><br>

- 3種類から3つ選んで並べる(3の3回分の階乗)<br>
<img src= "https://latex.codecogs.com/gif.latex?\LARGE&space;_{3}P_{3}=&space;3&space;\times2&space;\times&space;1" /><br>

きちんとした公式を使って求める方法もありますが、話が逸れるので別の記事にまとめました。
[順列(nPr)の総数を求める]()


# サンプルプログラム

紹介した順列の羅列方法を元にコードを書いてみます。

## 関数

```js
const getPermutation = (types, r) => {
  const result = [];

  // r が 1 の場合
  if (r === 1) {
    for (let i = 0; i < types.length; i++) {
      result[i] = [types[i]];
    }
    return result;
  }

  // r が 2以上の場合
  for (let i = 0; i < types.length; i++) {
    const parts = types.slice(0);
    parts.splice(i, 1)[0];
    const row = getPermutation(parts, r - 1);
    for (let j = 0; j < row.length; j++) {
      result.push([types[i]].concat(row[j]));
    }
  }

  return result;
};

```


## 4P1で実行した場合

### 実行結果


```js
const result = getPermutation(['ねずみ', 'うし', 'とら', 'うさぎ'], 1);
console.log(JSON.stringify(result));

// 実行結果
// [
//   ["ねずみ"],
//   ["うし"],
//   ["とら"],
//   ["うさぎ"]
// ]
```
### 解説

`r`が1だった場合は、以下の条件分岐に当てはまり、要素を1つずつ別の配列にしたものが返却されます。

```js
  if (r === 1) {
    for (let i = 0; i < types.length; i++) {
      result[i] = [types[i]];
    }
    return result;
  }
```

## 4P2で実行した場合

### 実行結果

```js

// 実行
const result = getPermutation(['ねずみ', 'うし', 'とら', 'うさぎ'], 2);
console.log(JSON.stringify(result));

// 実行結果
// [ 'ねずみ', 'うし' ]
// [ 'ねずみ', 'とら' ]
// [ 'ねずみ', 'うさぎ' ]
// [ 'うし', 'ねずみ' ]
// [ 'うし', 'とら' ]
// [ 'うし', 'うさぎ' ]
// [ 'とら', 'ねずみ' ]
// [ 'とら', 'うし' ]
// [ 'とら', 'うさぎ' ]
// [ 'うさぎ', 'ねずみ' ]
// [ 'うさぎ', 'うし' ]
// [ 'うさぎ', 'とら' ]

```

### 解説

関数が呼び出されて実行されるのは以下の処理です。

```js
for (let i = 0; i < n.length; i++) {
    const parts = n.slice(0);
    parts.splice(i, 1)[0];
    const row = getPermutation(parts, r - 1);
    for (let j = 0; j < row.length; j++) {
      result.push([n[i]].concat(row[j]));
      console.log([n[i]].concat(row[j]));
    }
  }
```

1行ずつ解説します。


#### `for (let i = 0; i < n.length; i++) {`


['ねずみ','うし','とら','うさぎ']の配列の長さ分(4回)ループします。

#### `const parts = n.slice(0);`<br>
「parts」という変数に `['ねずみ','うし','とら','うさぎ']`を代入しています。<br>
#### `.slice(0)`は値コピーのためにつけています。

参考:
[JavaScriptで配列のコピー（値渡し）](https://qiita.com/takahiro_itazuri/items/882d019f1d8215d1cb67)

#### `parts.splice(i, 1)[0];`<br>
`splice()`で配列の要素を一部削除しています。
ループ初回は`ねずみ`が削除され、partsの要素は`[ 'うし', 'とら', 'うさぎ' ]`だけになります。

#### `const row = getPermutation(parts, r - 1);`<br>
ここでは自分自身の関数を実行しています。<br>
内容は以下と同義です。

```js
const low = getPermutation(['うし', 'とら', 'うさぎ'], 1);

// lowの中身
// [
//   ["うし"],
//   ["とら"],
//   ["うさぎ"]
// ]
```

動きは4P1で解説した通りです。
lowには[["うし"],["とら"],["うさぎ"]]が格納されます。

このように自分自信を呼び出す処理が書かれた関数を「再帰関数」といいます。<br>
これについて詳しく知りたい方は以下の記事がおすすめです。

参考:
[再帰関数を学ぶと、どんな世界が広がるか](https://qiita.com/drken/items/23a4f604fa3f505dd5ad)

#### `for (let j = 0; j < row.length; j++) {`<br>
取得した[["うし"],["とら"],["うさぎ"]]の要素数(3回)分ループします。


#### `result.push([n[i]].concat(row[j]));`
`concat()`で`[ねずみ]`と`["うし"],["とら"],["うさぎ"]`をそれぞれ結合し、`result`配列に格納しています。<br>

```js
// result配列に格納される値
[
  [ 'ねずみ', 'うし' ],
  [ 'ねずみ', 'とら' ],
  [ 'ねずみ', 'うさぎ' ],
]
```


上記の動きをネズミ以外にも繰り返し実行することで最終的な結果が得られます。


# 参考

- 「nCr」についての記事ですが、お寿司で解説してるのがとてもわかりやすかったので参考にしました🍣<br>
    [５分で分かる！確率統計「nCr」の計算方法](https://blog.apar.jp/data-analysis/3927/)
-   ソースコードはこちらを参考にしました<br>
    [順列・組み合わせ のサンプルコード JS \[permutation\] \[combination\]](https://tech-blog.s-yoshiki.com/entry/144#%E9%A0%86%E5%88%97---permutation)
- とてもかわいい動物の素材はこちらにお借りしました。
[イラストレイン](https://illustrain.com/)
